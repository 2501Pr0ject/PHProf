[
  {
    "input": "Explique-moi l'injection de dépendances dans Symfony.",
    "output": "**TL;DR** : L'injection de dépendances (DI) permet de fournir automatiquement les services dont une classe a besoin, plutôt que de les créer manuellement.\n\n**Problème** : Sans DI, vos classes créent elles-mêmes leurs dépendances, ce qui rend le code difficile à tester et fortement couplé.\n\n**Solution** :\n```php\n<?php\n\nnamespace App\\Service;\n\nuse Psr\\Log\\LoggerInterface;\nuse Doctrine\\ORM\\EntityManagerInterface;\n\nclass UserService\n{\n    public function __construct(\n        private readonly EntityManagerInterface $entityManager,\n        private readonly LoggerInterface $logger,\n    ) {\n    }\n\n    public function createUser(string $email): User\n    {\n        $user = new User();\n        $user->setEmail($email);\n\n        $this->entityManager->persist($user);\n        $this->entityManager->flush();\n\n        $this->logger->info('Utilisateur créé', ['email' => $email]);\n\n        return $user;\n    }\n}\n```\n\n**Explication** : Symfony utilise l'**autowiring** pour injecter automatiquement les services. Dans l'exemple ci-dessus :\n\n1. Le constructeur déclare les dépendances avec leurs types (`EntityManagerInterface`, `LoggerInterface`)\n2. Symfony détecte ces types et injecte automatiquement les services correspondants\n3. Grâce à `readonly`, les propriétés sont immuables après construction\n\nLe container de services Symfony gère la création et l'injection. Vous n'avez pas besoin de créer manuellement vos services.\n\n**À retenir** :\n- Déclarez vos dépendances dans le constructeur avec leurs interfaces\n- Symfony injecte automatiquement grâce à l'autowiring\n- Utilisez `readonly` pour des propriétés immuables\n- Préférez les interfaces aux classes concrètes pour plus de flexibilité",
    "metadata": {
      "category": "concepts",
      "topic": "symfony_core",
      "difficulty": "intermediate",
      "tags": ["injection", "dépendances", "services", "autowiring"]
    }
  },
  {
    "input": "Comment créer un formulaire Symfony avec validation ?",
    "output": "**TL;DR** : Créez un FormType, ajoutez des contraintes de validation sur l'entité, puis traitez le formulaire dans le controller.\n\n**Problème** : Vous devez collecter des données utilisateur de manière sécurisée avec validation côté serveur.\n\n**Solution** :\n\n1. **Entité avec contraintes** :\n```php\n<?php\n\nnamespace App\\Entity;\n\nuse Symfony\\Component\\Validator\\Constraints as Assert;\n\nclass Contact\n{\n    #[Assert\\NotBlank(message: 'Le nom est obligatoire')]\n    #[Assert\\Length(min: 2, max: 100)]\n    private ?string $name = null;\n\n    #[Assert\\NotBlank]\n    #[Assert\\Email(message: 'Email invalide')]\n    private ?string $email = null;\n\n    #[Assert\\NotBlank]\n    #[Assert\\Length(min: 10, max: 1000)]\n    private ?string $message = null;\n\n    // Getters et setters...\n}\n```\n\n2. **FormType** :\n```php\n<?php\n\nnamespace App\\Form;\n\nuse App\\Entity\\Contact;\nuse Symfony\\Component\\Form\\AbstractType;\nuse Symfony\\Component\\Form\\Extension\\Core\\Type\\EmailType;\nuse Symfony\\Component\\Form\\Extension\\Core\\Type\\TextareaType;\nuse Symfony\\Component\\Form\\Extension\\Core\\Type\\TextType;\nuse Symfony\\Component\\Form\\FormBuilderInterface;\nuse Symfony\\Component\\OptionsResolver\\OptionsResolver;\n\nclass ContactType extends AbstractType\n{\n    public function buildForm(FormBuilderInterface $builder, array $options): void\n    {\n        $builder\n            ->add('name', TextType::class, [\n                'label' => 'Votre nom',\n            ])\n            ->add('email', EmailType::class, [\n                'label' => 'Votre email',\n            ])\n            ->add('message', TextareaType::class, [\n                'label' => 'Votre message',\n            ]);\n    }\n\n    public function configureOptions(OptionsResolver $resolver): void\n    {\n        $resolver->setDefaults([\n            'data_class' => Contact::class,\n        ]);\n    }\n}\n```\n\n3. **Controller** :\n```php\n<?php\n\nnamespace App\\Controller;\n\nuse App\\Entity\\Contact;\nuse App\\Form\\ContactType;\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route;\n\nclass ContactController extends AbstractController\n{\n    #[Route('/contact', name: 'app_contact')]\n    public function index(Request $request): Response\n    {\n        $contact = new Contact();\n        $form = $this->createForm(ContactType::class, $contact);\n\n        $form->handleRequest($request);\n\n        if ($form->isSubmitted() && $form->isValid()) {\n            // Traitement des données...\n            $this->addFlash('success', 'Message envoyé !');\n            return $this->redirectToRoute('app_contact');\n        }\n\n        return $this->render('contact/index.html.twig', [\n            'form' => $form,\n        ]);\n    }\n}\n```\n\n**Explication** : Le workflow Symfony Forms fonctionne ainsi :\n\n1. `createForm()` crée le formulaire lié à l'entité\n2. `handleRequest()` remplit l'entité avec les données POST\n3. `isSubmitted()` vérifie si le formulaire a été soumis\n4. `isValid()` déclenche la validation des contraintes\n\nLa protection CSRF est automatique avec Symfony Forms.\n\n**À retenir** :\n- Placez les contraintes de validation sur l'entité\n- Utilisez toujours `handleRequest()` avant `isSubmitted()`\n- La protection CSRF est automatique\n- Séparez la logique dans le FormType pour la réutilisabilité",
    "metadata": {
      "category": "concepts",
      "topic": "forms",
      "difficulty": "intermediate",
      "tags": ["formulaire", "validation", "form", "constraint"]
    }
  },
  {
    "input": "Ce code ne fonctionne pas, peux-tu m'aider ?\n```php\n$user = $repository->find($id);\necho $user->getName();\n```",
    "output": "**TL;DR** : La méthode `find()` peut retourner `null` si l'entité n'existe pas. Vous devez vérifier avant d'accéder aux propriétés.\n\n**Problème** : Si aucun utilisateur n'a l'ID demandé, `find()` retourne `null`. Appeler `getName()` sur `null` provoque une erreur fatale.\n\n**Solution** :\n```php\n<?php\n\n$user = $repository->find($id);\n\n// Option 1 : Vérification explicite\nif ($user === null) {\n    throw new \\RuntimeException('Utilisateur non trouvé');\n}\necho $user->getName();\n\n// Option 2 : Utiliser une exception Symfony (recommandé dans un controller)\nuse Symfony\\Component\\HttpKernel\\Exception\\NotFoundHttpException;\n\n$user = $repository->find($id);\nif (!$user) {\n    throw $this->createNotFoundException('Utilisateur non trouvé');\n}\n\n// Option 3 : Opérateur nullsafe (PHP 8+) pour un affichage optionnel\necho $user?->getName() ?? 'Utilisateur inconnu';\n\n// Option 4 : Utiliser findOrFail personnalisé dans le repository\nclass UserRepository extends ServiceEntityRepository\n{\n    public function findOrFail(int $id): User\n    {\n        $user = $this->find($id);\n        if (!$user) {\n            throw new EntityNotFoundException('User not found: ' . $id);\n        }\n        return $user;\n    }\n}\n```\n\n**Explication** : Le typage de retour de `find()` est `?User` (nullable). PHP n'autorise pas l'appel de méthodes sur `null`.\n\nEn Symfony, la bonne pratique dans un controller est d'utiliser `createNotFoundException()` qui retourne une erreur 404 propre au client.\n\nL'opérateur nullsafe `?->` de PHP 8 permet de court-circuiter l'appel si l'objet est `null`, mais masque le problème plutôt que de le traiter.\n\n**À retenir** :\n- `find()` retourne `null` si l'entité n'existe pas\n- Toujours vérifier le retour avant d'utiliser l'objet\n- Dans un controller, utilisez `createNotFoundException()`\n- Créez des méthodes `findOrFail()` dans vos repositories",
    "metadata": {
      "category": "debug",
      "topic": "doctrine",
      "difficulty": "beginner",
      "tags": ["null", "find", "repository", "erreur"]
    }
  },
  {
    "input": "Qu'est-ce qu'un Voter dans Symfony ?",
    "output": "**TL;DR** : Un Voter est une classe qui décide si un utilisateur peut effectuer une action sur un objet. C'est le mécanisme de contrôle d'accès granulaire de Symfony.\n\n**Problème** : Les simples rôles (ROLE_ADMIN, ROLE_USER) ne suffisent pas toujours. Par exemple : \"Un utilisateur peut modifier uniquement ses propres articles\".\n\n**Solution** :\n```php\n<?php\n\nnamespace App\\Security\\Voter;\n\nuse App\\Entity\\Article;\nuse App\\Entity\\User;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface;\nuse Symfony\\Component\\Security\\Core\\Authorization\\Voter\\Voter;\n\nclass ArticleVoter extends Voter\n{\n    public const EDIT = 'ARTICLE_EDIT';\n    public const DELETE = 'ARTICLE_DELETE';\n\n    protected function supports(string $attribute, mixed $subject): bool\n    {\n        return in_array($attribute, [self::EDIT, self::DELETE])\n            && $subject instanceof Article;\n    }\n\n    protected function voteOnAttribute(\n        string $attribute,\n        mixed $subject,\n        TokenInterface $token\n    ): bool {\n        $user = $token->getUser();\n\n        if (!$user instanceof User) {\n            return false;\n        }\n\n        /** @var Article $article */\n        $article = $subject;\n\n        return match ($attribute) {\n            self::EDIT => $this->canEdit($article, $user),\n            self::DELETE => $this->canDelete($article, $user),\n            default => false,\n        };\n    }\n\n    private function canEdit(Article $article, User $user): bool\n    {\n        // L'auteur peut éditer son article\n        return $article->getAuthor() === $user;\n    }\n\n    private function canDelete(Article $article, User $user): bool\n    {\n        // Seul l'auteur OU un admin peut supprimer\n        if ($article->getAuthor() === $user) {\n            return true;\n        }\n\n        return in_array('ROLE_ADMIN', $user->getRoles(), true);\n    }\n}\n```\n\n**Utilisation dans un controller** :\n```php\n#[Route('/article/{id}/edit', name: 'article_edit')]\npublic function edit(Article $article): Response\n{\n    // Vérifie automatiquement avec le Voter\n    $this->denyAccessUnlessGranted(ArticleVoter::EDIT, $article);\n\n    // ou avec isGranted()\n    if (!$this->isGranted(ArticleVoter::EDIT, $article)) {\n        throw $this->createAccessDeniedException();\n    }\n\n    // ...\n}\n```\n\n**Dans Twig** :\n```twig\n{% if is_granted('ARTICLE_EDIT', article) %}\n    <a href=\"{{ path('article_edit', {id: article.id}) }}\">Modifier</a>\n{% endif %}\n```\n\n**Explication** : Le système de Voters fonctionne par vote :\n\n1. `supports()` : Le Voter indique s'il peut gérer cette demande\n2. `voteOnAttribute()` : Le Voter retourne sa décision (true/false)\n3. La stratégie par défaut (`affirmative`) : un seul vote positif suffit\n\nSymfony appelle automatiquement tous les Voters enregistrés.\n\n**À retenir** :\n- Utilisez les Voters pour les autorisations basées sur les données\n- Un Voter = une responsabilité (un type d'entité)\n- Définissez des constantes pour les attributs\n- Testez toujours que `$user` est bien une instance de votre classe User",
    "metadata": {
      "category": "concepts",
      "topic": "security",
      "difficulty": "intermediate",
      "tags": ["voter", "sécurité", "autorisation", "accès"]
    }
  },
  {
    "input": "Comment utiliser les attributs PHP 8 dans Symfony ?",
    "output": "**TL;DR** : Les attributs PHP 8 remplacent les annotations Doctrine et permettent de configurer le routing, la validation, et l'ORM directement dans le code.\n\n**Problème** : Les annotations PHP doc-block ne sont pas natives au langage et nécessitent un parseur externe.\n\n**Solution** :\n\n**Routing avec attributs** :\n```php\n<?php\n\nnamespace App\\Controller;\n\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route;\n\n#[Route('/api', name: 'api_')]\nclass ApiController extends AbstractController\n{\n    #[Route('/users', name: 'users_list', methods: ['GET'])]\n    public function list(): Response\n    {\n        // ...\n    }\n\n    #[Route('/users/{id}', name: 'users_show', requirements: ['id' => '\\d+'])]\n    public function show(int $id): Response\n    {\n        // ...\n    }\n}\n```\n\n**Entité Doctrine avec attributs** :\n```php\n<?php\n\nnamespace App\\Entity;\n\nuse App\\Repository\\UserRepository;\nuse Doctrine\\DBAL\\Types\\Types;\nuse Doctrine\\ORM\\Mapping as ORM;\nuse Symfony\\Component\\Validator\\Constraints as Assert;\n\n#[ORM\\Entity(repositoryClass: UserRepository::class)]\n#[ORM\\Table(name: 'users')]\n#[ORM\\HasLifecycleCallbacks]\nclass User\n{\n    #[ORM\\Id]\n    #[ORM\\GeneratedValue]\n    #[ORM\\Column]\n    private ?int $id = null;\n\n    #[ORM\\Column(length: 180, unique: true)]\n    #[Assert\\NotBlank]\n    #[Assert\\Email]\n    private ?string $email = null;\n\n    #[ORM\\Column(type: Types::DATETIME_IMMUTABLE)]\n    private ?\\DateTimeImmutable $createdAt = null;\n\n    #[ORM\\PrePersist]\n    public function setCreatedAtValue(): void\n    {\n        $this->createdAt = new \\DateTimeImmutable();\n    }\n}\n```\n\n**Sécurité avec attributs** :\n```php\nuse Symfony\\Component\\Security\\Http\\Attribute\\IsGranted;\n\nclass AdminController extends AbstractController\n{\n    #[Route('/admin')]\n    #[IsGranted('ROLE_ADMIN')]\n    public function dashboard(): Response\n    {\n        // Accessible uniquement aux admins\n    }\n}\n```\n\n**Créer un attribut personnalisé** :\n```php\n<?php\n\nnamespace App\\Attribute;\n\n#[\\Attribute(\\Attribute::TARGET_METHOD)]\nclass RateLimit\n{\n    public function __construct(\n        public readonly int $maxRequests = 100,\n        public readonly int $periodSeconds = 3600,\n    ) {\n    }\n}\n\n// Utilisation\nclass ApiController\n{\n    #[RateLimit(maxRequests: 10, periodSeconds: 60)]\n    public function sensitiveAction(): Response\n    {\n        // ...\n    }\n}\n```\n\n**Explication** : Les attributs PHP 8 sont natifs au langage et offrent plusieurs avantages :\n\n1. **Typage** : Les arguments sont typés et validés à la compilation\n2. **IDE** : Meilleure autocomplétion et navigation\n3. **Performance** : Pas besoin de parser les doc-blocks\n4. **Réflexion** : Accès via `ReflectionClass::getAttributes()`\n\nSymfony 6+ utilise les attributs par défaut pour le routing, Doctrine, et la validation.\n\n**À retenir** :\n- Les attributs remplacent les annotations `@Route`, `@ORM\\Entity`, etc.\n- Utilisez les imports avec alias (`as ORM`, `as Assert`)\n- Les attributs sont compilés, donc plus rapides\n- Créez vos propres attributs pour de la métaprogrammation",
    "metadata": {
      "category": "concepts",
      "topic": "php_modern",
      "difficulty": "intermediate",
      "tags": ["attribut", "annotation", "php8", "routing"]
    }
  }
]
