[
  {
    "input": "Comment implémenter un Aggregate Root DDD avec Doctrine et les Domain Events ?",
    "output": "**TL;DR** : Un Aggregate Root est l'entité principale qui garantit les invariants métier et publie des Domain Events pour notifier les changements.\n\n**Problème** : Dans une architecture DDD, vous devez encapsuler la logique métier, protéger les invariants et communiquer les changements de manière découplée.\n\n**Solution** :\n\n1. **Interface et trait pour les Domain Events** :\n```php\n<?php\n\nnamespace App\\Domain\\Common;\n\ninterface DomainEventInterface\n{\n    public function occurredOn(): \\DateTimeImmutable;\n}\n\nabstract class AggregateRoot\n{\n    private array $domainEvents = [];\n\n    protected function recordEvent(DomainEventInterface $event): void\n    {\n        $this->domainEvents[] = $event;\n    }\n\n    public function pullDomainEvents(): array\n    {\n        $events = $this->domainEvents;\n        $this->domainEvents = [];\n        return $events;\n    }\n}\n```\n\n2. **Domain Event concret** :\n```php\n<?php\n\nnamespace App\\Domain\\Order\\Event;\n\nuse App\\Domain\\Common\\DomainEventInterface;\nuse App\\Domain\\Order\\ValueObject\\OrderId;\n\nfinal readonly class OrderWasPlaced implements DomainEventInterface\n{\n    public function __construct(\n        public OrderId $orderId,\n        public string $customerId,\n        public float $totalAmount,\n        private \\DateTimeImmutable $occurredOn = new \\DateTimeImmutable(),\n    ) {}\n\n    public function occurredOn(): \\DateTimeImmutable\n    {\n        return $this->occurredOn;\n    }\n}\n```\n\n3. **Aggregate Root Order** :\n```php\n<?php\n\nnamespace App\\Domain\\Order;\n\nuse App\\Domain\\Common\\AggregateRoot;\nuse App\\Domain\\Order\\Event\\OrderWasPlaced;\nuse App\\Domain\\Order\\Event\\OrderItemWasAdded;\nuse App\\Domain\\Order\\ValueObject\\OrderId;\nuse Doctrine\\Common\\Collections\\ArrayCollection;\nuse Doctrine\\Common\\Collections\\Collection;\nuse Doctrine\\ORM\\Mapping as ORM;\n\n#[ORM\\Entity]\n#[ORM\\Table(name: 'orders')]\nclass Order extends AggregateRoot\n{\n    #[ORM\\Id]\n    #[ORM\\Column(type: 'uuid')]\n    private string $id;\n\n    #[ORM\\Column]\n    private string $customerId;\n\n    #[ORM\\Column]\n    private string $status;\n\n    #[ORM\\OneToMany(targetEntity: OrderLine::class, mappedBy: 'order', cascade: ['persist'])]\n    private Collection $lines;\n\n    #[ORM\\Column(type: 'datetime_immutable')]\n    private \\DateTimeImmutable $createdAt;\n\n    private function __construct(OrderId $id, string $customerId)\n    {\n        $this->id = $id->value;\n        $this->customerId = $customerId;\n        $this->status = 'draft';\n        $this->lines = new ArrayCollection();\n        $this->createdAt = new \\DateTimeImmutable();\n    }\n\n    public static function place(OrderId $id, string $customerId): self\n    {\n        $order = new self($id, $customerId);\n        $order->recordEvent(new OrderWasPlaced(\n            orderId: $id,\n            customerId: $customerId,\n            totalAmount: 0,\n        ));\n        return $order;\n    }\n\n    public function addLine(string $productId, int $quantity, float $unitPrice): void\n    {\n        // Invariant : on ne peut pas modifier une commande confirmée\n        if ($this->status !== 'draft') {\n            throw new \\DomainException('Cannot modify a confirmed order');\n        }\n\n        // Invariant : quantité positive\n        if ($quantity <= 0) {\n            throw new \\InvalidArgumentException('Quantity must be positive');\n        }\n\n        $line = new OrderLine($this, $productId, $quantity, $unitPrice);\n        $this->lines->add($line);\n\n        $this->recordEvent(new OrderItemWasAdded(\n            orderId: new OrderId($this->id),\n            productId: $productId,\n            quantity: $quantity,\n        ));\n    }\n\n    public function confirm(): void\n    {\n        if ($this->lines->isEmpty()) {\n            throw new \\DomainException('Cannot confirm an empty order');\n        }\n\n        $this->status = 'confirmed';\n        $this->recordEvent(new OrderWasConfirmed(new OrderId($this->id)));\n    }\n\n    public function totalAmount(): float\n    {\n        return array_reduce(\n            $this->lines->toArray(),\n            fn(float $sum, OrderLine $line) => $sum + $line->lineTotal(),\n            0.0\n        );\n    }\n}\n```\n\n4. **Dispatcher des events via Doctrine Listener** :\n```php\n<?php\n\nnamespace App\\Infrastructure\\Doctrine;\n\nuse App\\Domain\\Common\\AggregateRoot;\nuse Doctrine\\Bundle\\DoctrineBundle\\Attribute\\AsDoctrineListener;\nuse Doctrine\\ORM\\Event\\PostFlushEventArgs;\nuse Doctrine\\ORM\\Event\\PostPersistEventArgs;\nuse Doctrine\\ORM\\Event\\PostUpdateEventArgs;\nuse Symfony\\Component\\Messenger\\MessageBusInterface;\n\n#[AsDoctrineListener(event: 'postPersist')]\n#[AsDoctrineListener(event: 'postUpdate')]\n#[AsDoctrineListener(event: 'postFlush')]\nclass DomainEventDispatcher\n{\n    private array $entities = [];\n\n    public function __construct(private MessageBusInterface $eventBus) {}\n\n    public function postPersist(PostPersistEventArgs $args): void\n    {\n        $this->collectEvents($args->getObject());\n    }\n\n    public function postUpdate(PostUpdateEventArgs $args): void\n    {\n        $this->collectEvents($args->getObject());\n    }\n\n    private function collectEvents(object $entity): void\n    {\n        if ($entity instanceof AggregateRoot) {\n            $this->entities[] = $entity;\n        }\n    }\n\n    public function postFlush(PostFlushEventArgs $args): void\n    {\n        foreach ($this->entities as $entity) {\n            foreach ($entity->pullDomainEvents() as $event) {\n                $this->eventBus->dispatch($event);\n            }\n        }\n        $this->entities = [];\n    }\n}\n```\n\n**Explication** :\n\n1. **Aggregate Root** : Entité racine qui contrôle l'accès à ses entités enfants (OrderLine). Toute modification passe par l'Aggregate Root.\n\n2. **Invariants** : Règles métier garanties par l'Aggregate (quantité positive, commande non vide pour confirmer).\n\n3. **Domain Events** : Enregistrés pendant les opérations, dispatchés après le flush Doctrine pour garantir la cohérence.\n\n4. **Constructeur privé + Factory** : Force l'utilisation de méthodes métier (`place()`) pour créer l'aggregate.\n\n**À retenir** :\n- L'Aggregate Root est la seule entrée pour modifier ses entités enfants\n- Les invariants sont vérifiés dans les méthodes métier, pas dans les setters\n- Les Domain Events sont collectés puis dispatchés après la transaction\n- Utilisez des Value Objects pour les identifiants (`OrderId`)\n- Le constructeur privé force l'utilisation des factory methods",
    "metadata": {
      "category": "concepts",
      "topic": "ddd_advanced",
      "difficulty": "advanced",
      "tags": ["DDD", "Aggregate", "Domain Events", "Doctrine", "architecture"]
    }
  },
  {
    "input": "Comment configurer le Second Level Cache de Doctrine ?",
    "output": "**TL;DR** : Le Second Level Cache (L2) de Doctrine stocke les entités en cache partagé entre requêtes, réduisant drastiquement les accès base de données.\n\n**Problème** : Le cache de premier niveau (Identity Map) ne persiste que pendant une requête. Pour des données peu volatiles, vous voulez un cache partagé.\n\n**Solution** :\n\n1. **Configuration dans doctrine.yaml** :\n```yaml\n# config/packages/doctrine.yaml\ndoctrine:\n    orm:\n        second_level_cache:\n            enabled: true\n            region_cache_driver:\n                type: pool\n                pool: doctrine.second_level_cache_pool\n            region_lock_lifetime: 60\n            region_lifetime: 3600\n            log_enabled: '%kernel.debug%'\n            \n            regions:\n                # Région par défaut\n                default:\n                    lifetime: 3600\n                    cache_driver:\n                        type: pool\n                        pool: doctrine.second_level_cache_pool\n                \n                # Région pour données quasi-statiques\n                static_data:\n                    lifetime: 86400  # 24h\n                    cache_driver:\n                        type: pool\n                        pool: doctrine.static_cache_pool\n                \n                # Région pour données fréquemment modifiées\n                volatile_data:\n                    lifetime: 300  # 5 min\n                    cache_driver:\n                        type: pool\n                        pool: doctrine.volatile_cache_pool\n```\n\n2. **Configuration des pools de cache** :\n```yaml\n# config/packages/cache.yaml\nframework:\n    cache:\n        pools:\n            doctrine.second_level_cache_pool:\n                adapter: cache.adapter.redis\n                provider: 'redis://localhost:6379'\n                default_lifetime: 3600\n            \n            doctrine.static_cache_pool:\n                adapter: cache.adapter.redis\n                provider: 'redis://localhost:6379'\n                default_lifetime: 86400\n            \n            doctrine.volatile_cache_pool:\n                adapter: cache.adapter.redis\n                provider: 'redis://localhost:6379'\n                default_lifetime: 300\n```\n\n3. **Configuration sur les entités** :\n```php\n<?php\n\nnamespace App\\Entity;\n\nuse Doctrine\\ORM\\Mapping as ORM;\n\n// Entité quasi-statique (pays, devises...)\n#[ORM\\Entity]\n#[ORM\\Cache(usage: 'READ_ONLY', region: 'static_data')]\nclass Country\n{\n    #[ORM\\Id]\n    #[ORM\\Column(length: 2)]\n    private string $code;\n\n    #[ORM\\Column(length: 100)]\n    private string $name;\n}\n\n// Entité avec lectures fréquentes, écritures rares\n#[ORM\\Entity]\n#[ORM\\Cache(usage: 'NONSTRICT_READ_WRITE', region: 'default')]\nclass Category\n{\n    #[ORM\\Id]\n    #[ORM\\GeneratedValue]\n    #[ORM\\Column]\n    private ?int $id = null;\n\n    #[ORM\\Column]\n    private string $name;\n\n    // Cache la collection aussi\n    #[ORM\\OneToMany(targetEntity: Product::class, mappedBy: 'category')]\n    #[ORM\\Cache(usage: 'NONSTRICT_READ_WRITE')]\n    private Collection $products;\n}\n\n// Entité avec écritures concurrentes\n#[ORM\\Entity]\n#[ORM\\Cache(usage: 'READ_WRITE', region: 'volatile_data')]\nclass Product\n{\n    #[ORM\\Id]\n    #[ORM\\GeneratedValue]\n    #[ORM\\Column]\n    private ?int $id = null;\n\n    #[ORM\\Column]\n    #[ORM\\Version]\n    private int $version = 1;  // Requis pour READ_WRITE\n\n    #[ORM\\ManyToOne(targetEntity: Category::class, inversedBy: 'products')]\n    #[ORM\\Cache(usage: 'NONSTRICT_READ_WRITE')]\n    private ?Category $category = null;\n}\n```\n\n4. **Stratégies de cache (usage)** :\n```php\n<?php\n\n// READ_ONLY : Données jamais modifiées après insertion\n// - Plus performant\n// - Pas de lock\n// - Exception si on tente de modifier\n#[ORM\\Cache(usage: 'READ_ONLY')]\nclass Currency {}\n\n// NONSTRICT_READ_WRITE : Lectures fréquentes, écritures rares\n// - Pas de lock\n// - Risque de données légèrement périmées (eventual consistency)\n// - Bon compromis performance/cohérence\n#[ORM\\Cache(usage: 'NONSTRICT_READ_WRITE')]\nclass Category {}\n\n// READ_WRITE : Cohérence stricte requise\n// - Utilise des locks\n// - Requiert un champ @Version\n// - Plus lent mais cohérent\n#[ORM\\Cache(usage: 'READ_WRITE')]\nclass Product {}\n```\n\n5. **Cache des requêtes** :\n```php\n<?php\n\nclass ProductRepository extends ServiceEntityRepository\n{\n    public function findActiveByCategory(int $categoryId): array\n    {\n        return $this->createQueryBuilder('p')\n            ->where('p.category = :categoryId')\n            ->andWhere('p.active = true')\n            ->setParameter('categoryId', $categoryId)\n            ->getQuery()\n            // Cache le résultat de cette requête\n            ->enableResultCache(\n                lifetime: 300,\n                resultCacheId: 'products_category_' . $categoryId\n            )\n            ->getResult();\n    }\n\n    public function invalidateCategoryCache(int $categoryId): void\n    {\n        $this->getEntityManager()\n            ->getConfiguration()\n            ->getResultCache()\n            ->delete('products_category_' . $categoryId);\n    }\n}\n```\n\n6. **Invalidation manuelle** :\n```php\n<?php\n\nclass CacheInvalidator\n{\n    public function __construct(\n        private EntityManagerInterface $em,\n    ) {}\n\n    public function evictEntity(object $entity): void\n    {\n        $cache = $this->em->getCache();\n        $className = get_class($entity);\n        $id = $this->em->getClassMetadata($className)\n            ->getIdentifierValues($entity);\n\n        $cache->evictEntity($className, $id);\n    }\n\n    public function evictCollection(string $className, string $association, mixed $ownerId): void\n    {\n        $this->em->getCache()->evictCollection($className, $association, $ownerId);\n    }\n\n    public function evictAllRegion(string $regionName): void\n    {\n        $this->em->getCache()->evictEntityRegion($regionName);\n    }\n}\n```\n\n**Explication** :\n\n| Mode | Lock | Cohérence | Performance | Cas d'usage |\n|------|------|-----------|-------------|-------------|\n| READ_ONLY | Non | Parfaite | Excellente | Référentiels statiques |\n| NONSTRICT_READ_WRITE | Non | Éventuelle | Très bonne | Données peu modifiées |\n| READ_WRITE | Oui | Stricte | Moyenne | Données critiques concurrentes |\n\n**À retenir** :\n- Commencez par `NONSTRICT_READ_WRITE` pour la plupart des cas\n- `READ_ONLY` pour les vraies données statiques (pays, devises)\n- `READ_WRITE` uniquement si la cohérence est critique et requiert `@Version`\n- Cachez aussi les collections avec `#[ORM\\Cache]` sur les relations\n- Utilisez des régions différentes pour des TTL différents\n- Invalidez le cache lors des modifications en dehors de Doctrine (import SQL)",
    "metadata": {
      "category": "concepts",
      "topic": "doctrine_advanced",
      "difficulty": "advanced",
      "tags": ["Doctrine", "cache", "L2", "performance", "Redis"]
    }
  },
  {
    "input": "Comment implémenter le pattern Specification pour des règles métier complexes ?",
    "output": "**TL;DR** : Le pattern Specification encapsule des règles métier réutilisables et combinables (AND, OR, NOT) pour filtrer ou valider des objets.\n\n**Problème** : Les règles métier sont dispersées dans le code, dupliquées, et difficiles à tester. Vous voulez des règles composables et réutilisables.\n\n**Solution** :\n\n1. **Interface Specification** :\n```php\n<?php\n\nnamespace App\\Domain\\Specification;\n\n/**\n * @template T\n */\ninterface SpecificationInterface\n{\n    /**\n     * @param T $candidate\n     */\n    public function isSatisfiedBy(mixed $candidate): bool;\n}\n\n/**\n * @template T\n */\nabstract class CompositeSpecification implements SpecificationInterface\n{\n    /**\n     * @param SpecificationInterface<T> $other\n     * @return SpecificationInterface<T>\n     */\n    public function and(SpecificationInterface $other): SpecificationInterface\n    {\n        return new AndSpecification($this, $other);\n    }\n\n    /**\n     * @param SpecificationInterface<T> $other\n     * @return SpecificationInterface<T>\n     */\n    public function or(SpecificationInterface $other): SpecificationInterface\n    {\n        return new OrSpecification($this, $other);\n    }\n\n    /**\n     * @return SpecificationInterface<T>\n     */\n    public function not(): SpecificationInterface\n    {\n        return new NotSpecification($this);\n    }\n}\n```\n\n2. **Specifications composites** :\n```php\n<?php\n\nnamespace App\\Domain\\Specification;\n\n/**\n * @template T\n * @extends CompositeSpecification<T>\n */\nfinal class AndSpecification extends CompositeSpecification\n{\n    public function __construct(\n        private readonly SpecificationInterface $left,\n        private readonly SpecificationInterface $right,\n    ) {}\n\n    public function isSatisfiedBy(mixed $candidate): bool\n    {\n        return $this->left->isSatisfiedBy($candidate)\n            && $this->right->isSatisfiedBy($candidate);\n    }\n}\n\n/**\n * @template T\n * @extends CompositeSpecification<T>\n */\nfinal class OrSpecification extends CompositeSpecification\n{\n    public function __construct(\n        private readonly SpecificationInterface $left,\n        private readonly SpecificationInterface $right,\n    ) {}\n\n    public function isSatisfiedBy(mixed $candidate): bool\n    {\n        return $this->left->isSatisfiedBy($candidate)\n            || $this->right->isSatisfiedBy($candidate);\n    }\n}\n\n/**\n * @template T\n * @extends CompositeSpecification<T>\n */\nfinal class NotSpecification extends CompositeSpecification\n{\n    public function __construct(\n        private readonly SpecificationInterface $specification,\n    ) {}\n\n    public function isSatisfiedBy(mixed $candidate): bool\n    {\n        return !$this->specification->isSatisfiedBy($candidate);\n    }\n}\n```\n\n3. **Specifications métier concrètes** :\n```php\n<?php\n\nnamespace App\\Domain\\Order\\Specification;\n\nuse App\\Domain\\Order\\Order;\nuse App\\Domain\\Specification\\CompositeSpecification;\n\n/**\n * @extends CompositeSpecification<Order>\n */\nfinal class OrderIsPaidSpecification extends CompositeSpecification\n{\n    public function isSatisfiedBy(mixed $candidate): bool\n    {\n        return $candidate->isPaid();\n    }\n}\n\n/**\n * @extends CompositeSpecification<Order>\n */\nfinal class OrderIsShippableSpecification extends CompositeSpecification\n{\n    public function isSatisfiedBy(mixed $candidate): bool\n    {\n        return $candidate->hasShippingAddress()\n            && $candidate->allItemsInStock();\n    }\n}\n\n/**\n * @extends CompositeSpecification<Order>\n */\nfinal class OrderTotalExceedsSpecification extends CompositeSpecification\n{\n    public function __construct(\n        private readonly float $minimumAmount,\n    ) {}\n\n    public function isSatisfiedBy(mixed $candidate): bool\n    {\n        return $candidate->totalAmount() >= $this->minimumAmount;\n    }\n}\n\n/**\n * @extends CompositeSpecification<Order>\n */\nfinal class OrderBelongsToCustomerSpecification extends CompositeSpecification\n{\n    public function __construct(\n        private readonly string $customerId,\n    ) {}\n\n    public function isSatisfiedBy(mixed $candidate): bool\n    {\n        return $candidate->customerId() === $this->customerId;\n    }\n}\n\n/**\n * @extends CompositeSpecification<Order>\n */\nfinal class OrderIsOlderThanSpecification extends CompositeSpecification\n{\n    public function __construct(\n        private readonly \\DateInterval $interval,\n    ) {}\n\n    public function isSatisfiedBy(mixed $candidate): bool\n    {\n        $threshold = (new \\DateTimeImmutable())->sub($this->interval);\n        return $candidate->createdAt() < $threshold;\n    }\n}\n```\n\n4. **Utilisation avec composition** :\n```php\n<?php\n\nnamespace App\\Application\\Service;\n\nuse App\\Domain\\Order\\Order;\nuse App\\Domain\\Order\\Specification\\*;\n\nclass OrderService\n{\n    public function canShipOrder(Order $order): bool\n    {\n        // Règle : commande payée ET expédiable\n        $spec = (new OrderIsPaidSpecification())\n            ->and(new OrderIsShippableSpecification());\n\n        return $spec->isSatisfiedBy($order);\n    }\n\n    public function canApplyLoyaltyDiscount(Order $order, string $customerId): bool\n    {\n        // Règle : commande >= 100€ ET appartient au client ET pas encore payée\n        $spec = (new OrderTotalExceedsSpecification(100.0))\n            ->and(new OrderBelongsToCustomerSpecification($customerId))\n            ->and((new OrderIsPaidSpecification())->not());\n\n        return $spec->isSatisfiedBy($order);\n    }\n\n    public function findOrdersToArchive(array $orders): array\n    {\n        // Règle : commandes de plus de 2 ans ET payées\n        $spec = (new OrderIsOlderThanSpecification(new \\DateInterval('P2Y')))\n            ->and(new OrderIsPaidSpecification());\n\n        return array_filter(\n            $orders,\n            fn(Order $order) => $spec->isSatisfiedBy($order)\n        );\n    }\n}\n```\n\n5. **Specification avec Doctrine QueryBuilder** :\n```php\n<?php\n\nnamespace App\\Infrastructure\\Doctrine\\Specification;\n\nuse Doctrine\\ORM\\QueryBuilder;\n\ninterface DoctrineSpecificationInterface\n{\n    public function apply(QueryBuilder $qb, string $alias): void;\n}\n\nfinal class OrderIsPaidDoctrineSpecification implements DoctrineSpecificationInterface\n{\n    public function apply(QueryBuilder $qb, string $alias): void\n    {\n        $qb->andWhere(\"$alias.paidAt IS NOT NULL\");\n    }\n}\n\nfinal class OrderTotalExceedsDoctrineSpecification implements DoctrineSpecificationInterface\n{\n    public function __construct(private readonly float $amount) {}\n\n    public function apply(QueryBuilder $qb, string $alias): void\n    {\n        $qb->andWhere(\"$alias.totalAmount >= :minAmount\")\n           ->setParameter('minAmount', $this->amount);\n    }\n}\n\n// Repository utilisant les specifications\nclass OrderRepository extends ServiceEntityRepository\n{\n    /**\n     * @param DoctrineSpecificationInterface[] $specifications\n     */\n    public function findBySpecifications(array $specifications): array\n    {\n        $qb = $this->createQueryBuilder('o');\n\n        foreach ($specifications as $spec) {\n            $spec->apply($qb, 'o');\n        }\n\n        return $qb->getQuery()->getResult();\n    }\n}\n```\n\n**Explication** :\n\n| Avantage | Description |\n|----------|-------------|\n| **Réutilisabilité** | Une specification = une règle, réutilisable partout |\n| **Composabilité** | Combine avec `and()`, `or()`, `not()` |\n| **Testabilité** | Chaque règle testable isolément |\n| **Lisibilité** | Le code exprime clairement les règles métier |\n| **Single Responsibility** | Chaque specification a une seule responsabilité |\n\n**À retenir** :\n- Créez des specifications atomiques (une seule règle par classe)\n- Utilisez la composition pour les règles complexes\n- Séparez les specifications in-memory (domain) et Doctrine (infrastructure)\n- Les specifications sont parfaites pour les règles métier réutilisées en validation ET en filtrage\n- Nommez les specifications de façon explicite : `OrderIsPaid`, pas `CheckPayment`",
    "metadata": {
      "category": "concepts",
      "topic": "architecture_advanced",
      "difficulty": "advanced",
      "tags": ["Specification", "DDD", "pattern", "composition", "règles métier"]
    }
  },
  {
    "input": "Comment configurer Messenger avec retry, failure transport et dead letter queue ?",
    "output": "**TL;DR** : Configurez des transports avec retry automatique, un failure transport pour les messages échoués, et des stratégies de récupération pour une messagerie robuste.\n\n**Problème** : En production, les messages peuvent échouer (service externe down, timeout). Vous devez gérer les retries, les échecs définitifs et pouvoir rejouer les messages.\n\n**Solution** :\n\n1. **Configuration complète messenger.yaml** :\n```yaml\n# config/packages/messenger.yaml\nframework:\n    messenger:\n        # Serializer personnalisé pour les messages\n        default_serializer: messenger.transport.symfony_serializer\n        serializer:\n            default_serializer: messenger.transport.symfony_serializer\n            symfony_serializer:\n                format: json\n                context: {}\n\n        # Failure transport global\n        failure_transport: failed\n\n        # Définition des transports\n        transports:\n            # Transport asynchrone principal\n            async:\n                dsn: '%env(MESSENGER_TRANSPORT_DSN)%'\n                options:\n                    exchange:\n                        name: messages\n                        type: direct\n                    queues:\n                        messages:\n                            binding_keys: [messages]\n                retry_strategy:\n                    max_retries: 3\n                    delay: 1000  # 1 seconde\n                    multiplier: 2  # Backoff exponentiel\n                    max_delay: 60000  # Max 1 minute\n                failure_transport: failed\n\n            # Transport pour jobs longs\n            async_priority_high:\n                dsn: '%env(MESSENGER_TRANSPORT_DSN)%'\n                options:\n                    exchange:\n                        name: high_priority\n                        type: direct\n                    queues:\n                        high_priority:\n                            binding_keys: [high_priority]\n                retry_strategy:\n                    max_retries: 5\n                    delay: 500\n                    multiplier: 3\n                    max_delay: 300000  # 5 minutes\n                failure_transport: failed_critical\n\n            # Transport pour emails (tolérant aux échecs)\n            async_emails:\n                dsn: 'doctrine://default?queue_name=emails'\n                retry_strategy:\n                    max_retries: 10\n                    delay: 60000  # 1 minute\n                    multiplier: 2\n                    max_delay: 3600000  # 1 heure\n                failure_transport: failed\n\n            # Failure transport standard\n            failed:\n                dsn: 'doctrine://default?queue_name=failed'\n\n            # Failure transport critique (alertes)\n            failed_critical:\n                dsn: 'doctrine://default?queue_name=failed_critical'\n\n            # Transport synchrone pour les tests\n            sync: 'sync://'\n\n        # Routing des messages vers les transports\n        routing:\n            # Par défaut async\n            '*': async\n\n            # Messages spécifiques\n            'App\\Message\\SendEmailMessage': async_emails\n            'App\\Message\\ProcessPaymentMessage': async_priority_high\n            'App\\Message\\GenerateReportMessage': async_priority_high\n            \n            # Messages sync (pour tests ou cas spéciaux)\n            'App\\Message\\SyncMessage': sync\n```\n\n2. **Message avec configuration de retry personnalisée** :\n```php\n<?php\n\nnamespace App\\Message;\n\nuse Symfony\\Component\\Messenger\\Stamp\\DelayStamp;\n\n// Message standard\nfinal readonly class ProcessOrderMessage\n{\n    public function __construct(\n        public int $orderId,\n        public int $attemptCount = 0,\n    ) {}\n\n    public function withIncrementedAttempt(): self\n    {\n        return new self($this->orderId, $this->attemptCount + 1);\n    }\n}\n\n// Message avec retry custom via attribut\nuse Symfony\\Component\\Messenger\\Attribute\\AsMessage;\n\n#[AsMessage(transport: 'async_priority_high')]\nfinal readonly class CriticalPaymentMessage\n{\n    public function __construct(\n        public string $paymentId,\n        public float $amount,\n    ) {}\n}\n```\n\n3. **Handler avec gestion d'erreurs granulaire** :\n```php\n<?php\n\nnamespace App\\MessageHandler;\n\nuse App\\Message\\ProcessOrderMessage;\nuse Symfony\\Component\\Messenger\\Attribute\\AsMessageHandler;\nuse Symfony\\Component\\Messenger\\Exception\\RecoverableMessageHandlingException;\nuse Symfony\\Component\\Messenger\\Exception\\UnrecoverableMessageHandlingException;\n\n#[AsMessageHandler]\nfinal class ProcessOrderHandler\n{\n    public function __construct(\n        private PaymentGateway $paymentGateway,\n        private LoggerInterface $logger,\n    ) {}\n\n    public function __invoke(ProcessOrderMessage $message): void\n    {\n        try {\n            $this->paymentGateway->charge($message->orderId);\n            \n        } catch (GatewayTimeoutException $e) {\n            // Erreur temporaire -> retry automatique\n            $this->logger->warning('Payment gateway timeout, will retry', [\n                'orderId' => $message->orderId,\n                'attempt' => $message->attemptCount,\n            ]);\n            \n            throw new RecoverableMessageHandlingException(\n                'Gateway temporarily unavailable',\n                previous: $e\n            );\n            \n        } catch (InvalidCardException $e) {\n            // Erreur définitive -> pas de retry, va dans failed\n            $this->logger->error('Invalid card, no retry', [\n                'orderId' => $message->orderId,\n            ]);\n            \n            throw new UnrecoverableMessageHandlingException(\n                'Payment definitely failed: ' . $e->getMessage(),\n                previous: $e\n            );\n            \n        } catch (\\Throwable $e) {\n            // Erreur inconnue -> retry par défaut\n            $this->logger->error('Unexpected error processing order', [\n                'orderId' => $message->orderId,\n                'error' => $e->getMessage(),\n            ]);\n            \n            throw $e;  // Sera retryé selon la config\n        }\n    }\n}\n```\n\n4. **Event Subscriber pour monitoring des échecs** :\n```php\n<?php\n\nnamespace App\\EventSubscriber;\n\nuse Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\nuse Symfony\\Component\\Messenger\\Event\\WorkerMessageFailedEvent;\nuse Symfony\\Component\\Messenger\\Event\\WorkerMessageRetriedEvent;\nuse Symfony\\Component\\Messenger\\Stamp\\RedeliveryStamp;\n\nfinal class MessengerFailureSubscriber implements EventSubscriberInterface\n{\n    public function __construct(\n        private LoggerInterface $logger,\n        private AlertService $alertService,\n    ) {}\n\n    public static function getSubscribedEvents(): array\n    {\n        return [\n            WorkerMessageFailedEvent::class => 'onMessageFailed',\n            WorkerMessageRetriedEvent::class => 'onMessageRetried',\n        ];\n    }\n\n    public function onMessageFailed(WorkerMessageFailedEvent $event): void\n    {\n        $envelope = $event->getEnvelope();\n        $message = $envelope->getMessage();\n        $throwable = $event->getThrowable();\n\n        // Récupère le nombre de retries\n        $retryCount = 0;\n        foreach ($envelope->all(RedeliveryStamp::class) as $stamp) {\n            $retryCount = max($retryCount, $stamp->getRetryCount());\n        }\n\n        $context = [\n            'message_class' => get_class($message),\n            'retry_count' => $retryCount,\n            'will_retry' => $event->willRetry(),\n            'error' => $throwable->getMessage(),\n            'transport' => $event->getReceiverName(),\n        ];\n\n        if ($event->willRetry()) {\n            $this->logger->warning('Message will be retried', $context);\n        } else {\n            // Échec définitif -> alerte\n            $this->logger->error('Message failed permanently', $context);\n            $this->alertService->sendCriticalAlert(\n                \"Message {$context['message_class']} failed after {$retryCount} retries\"\n            );\n        }\n    }\n\n    public function onMessageRetried(WorkerMessageRetriedEvent $event): void\n    {\n        $this->logger->info('Message being retried', [\n            'message_class' => get_class($event->getEnvelope()->getMessage()),\n        ]);\n    }\n}\n```\n\n5. **Commandes pour gérer les failed messages** :\n```bash\n# Voir les messages en échec\nphp bin/console messenger:failed:show\n\n# Voir les détails d'un message\nphp bin/console messenger:failed:show 123 -vv\n\n# Rejouer un message spécifique\nphp bin/console messenger:failed:retry 123\n\n# Rejouer tous les messages\nphp bin/console messenger:failed:retry --force\n\n# Supprimer un message\nphp bin/console messenger:failed:remove 123\n\n# Supprimer les vieux messages (custom command)\nphp bin/console app:messenger:cleanup-failed --older-than=\"7 days\"\n```\n\n6. **Commande de cleanup personnalisée** :\n```php\n<?php\n\nnamespace App\\Command;\n\nuse Doctrine\\DBAL\\Connection;\nuse Symfony\\Component\\Console\\Attribute\\AsCommand;\nuse Symfony\\Component\\Console\\Command\\Command;\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Input\\InputOption;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\n\n#[AsCommand(\n    name: 'app:messenger:cleanup-failed',\n    description: 'Remove old failed messages'\n)]\nfinal class CleanupFailedMessagesCommand extends Command\n{\n    public function __construct(private Connection $connection)\n    {\n        parent::__construct();\n    }\n\n    protected function configure(): void\n    {\n        $this->addOption(\n            'older-than',\n            null,\n            InputOption::VALUE_REQUIRED,\n            'Remove messages older than this (e.g., \"7 days\")',\n            '30 days'\n        );\n    }\n\n    protected function execute(InputInterface $input, OutputInterface $output): int\n    {\n        $threshold = new \\DateTimeImmutable('-' . $input->getOption('older-than'));\n\n        $deleted = $this->connection->executeStatement(\n            'DELETE FROM messenger_messages WHERE queue_name = ? AND created_at < ?',\n            ['failed', $threshold->format('Y-m-d H:i:s')]\n        );\n\n        $output->writeln(\"<info>Deleted $deleted old failed messages</info>\");\n\n        return Command::SUCCESS;\n    }\n}\n```\n\n**Explication** :\n\n| Exception Type | Comportement | Cas d'usage |\n|----------------|--------------|-------------|\n| `RecoverableMessageHandlingException` | Force le retry | Timeout, service temporairement down |\n| `UnrecoverableMessageHandlingException` | Pas de retry, va direct dans failed | Données invalides, erreur métier |\n| Autres exceptions | Retry selon config transport | Erreurs inattendues |\n\n**À retenir** :\n- Configurez un `failure_transport` pour chaque transport critique\n- Utilisez le backoff exponentiel (`multiplier`) pour éviter de surcharger les services\n- `RecoverableMessageHandlingException` pour les erreurs temporaires\n- `UnrecoverableMessageHandlingException` pour les erreurs définitives\n- Monitorez les failed transports avec des alertes\n- Nettoyez régulièrement les vieux messages en échec",
    "metadata": {
      "category": "concepts",
      "topic": "messenger_advanced",
      "difficulty": "advanced",
      "tags": ["Messenger", "retry", "failure", "dead letter", "queue", "async"]
    }
  },
  {
    "input": "Mon worker Messenger consomme de plus en plus de mémoire. Comment diagnostiquer et résoudre ?",
    "output": "**TL;DR** : Les memory leaks dans les workers viennent souvent de Doctrine (entités non détachées), de services stateful, ou de collections qui grossissent. Utilisez `--memory-limit` et implémentez `ResetInterface`.\n\n**Problème** : Les workers long-running accumulent de la mémoire à chaque message traité, jusqu'à atteindre la limite et être tués.\n\n**Solution** :\n\n1. **Configuration du worker avec limites** :\n```bash\n# En production, toujours avec des limites\nphp bin/console messenger:consume async \\\n    --memory-limit=128M \\\n    --time-limit=3600 \\\n    --limit=1000 \\\n    -vv\n\n# Supervisor config\n# /etc/supervisor/conf.d/messenger-worker.conf\n[program:messenger-consume]\ncommand=php /var/www/app/bin/console messenger:consume async --memory-limit=128M --time-limit=3600\nautorestart=true\nnumprocs=2\nuser=www-data\nstdout_logfile=/var/log/messenger.log\nstderr_logfile=/var/log/messenger-error.log\n```\n\n2. **Le problème Doctrine : Identity Map** :\n```php\n<?php\n\nnamespace App\\MessageHandler;\n\nuse Doctrine\\ORM\\EntityManagerInterface;\n\n// ❌ MAUVAIS : Les entités s'accumulent\n#[AsMessageHandler]\nfinal class BadHandler\n{\n    public function __construct(\n        private EntityManagerInterface $em,\n        private OrderRepository $orderRepository,\n    ) {}\n\n    public function __invoke(ProcessOrderMessage $message): void\n    {\n        // Chaque appel charge des entités dans l'Identity Map\n        $order = $this->orderRepository->find($message->orderId);\n        \n        // Elles restent en mémoire jusqu'à la fin du worker !\n        foreach ($order->getLines() as $line) {\n            // ...\n        }\n    }\n}\n\n// ✅ BON : Clear l'EntityManager après chaque message\n#[AsMessageHandler]\nfinal class GoodHandler\n{\n    public function __construct(\n        private EntityManagerInterface $em,\n        private OrderRepository $orderRepository,\n    ) {}\n\n    public function __invoke(ProcessOrderMessage $message): void\n    {\n        try {\n            $order = $this->orderRepository->find($message->orderId);\n            \n            foreach ($order->getLines() as $line) {\n                // ...\n            }\n            \n            $this->em->flush();\n        } finally {\n            // Libère TOUTES les entités de l'Identity Map\n            $this->em->clear();\n        }\n    }\n}\n```\n\n3. **Solution globale : Middleware de reset** :\n```php\n<?php\n\nnamespace App\\Messenger\\Middleware;\n\nuse Doctrine\\ORM\\EntityManagerInterface;\nuse Symfony\\Component\\Messenger\\Envelope;\nuse Symfony\\Component\\Messenger\\Middleware\\MiddlewareInterface;\nuse Symfony\\Component\\Messenger\\Middleware\\StackInterface;\n\nfinal class DoctrineClearMiddleware implements MiddlewareInterface\n{\n    public function __construct(\n        private EntityManagerInterface $em,\n    ) {}\n\n    public function handle(Envelope $envelope, StackInterface $stack): Envelope\n    {\n        try {\n            return $stack->next()->handle($envelope, $stack);\n        } finally {\n            $this->em->clear();\n            \n            // Force le garbage collector\n            if (gc_enabled()) {\n                gc_collect_cycles();\n            }\n        }\n    }\n}\n```\n\n4. **Configuration du middleware** :\n```yaml\n# config/packages/messenger.yaml\nframework:\n    messenger:\n        buses:\n            messenger.bus.default:\n                middleware:\n                    # Doctrine transaction (intégré)\n                    - doctrine_transaction\n                    \n                    # Votre middleware de clear\n                    - App\\Messenger\\Middleware\\DoctrineClearMiddleware\n```\n\n5. **Services stateful : implémenter ResetInterface** :\n```php\n<?php\n\nnamespace App\\Service;\n\nuse Symfony\\Contracts\\Service\\ResetInterface;\n\n// ❌ MAUVAIS : Le cache interne grossit indéfiniment\nfinal class BadCacheService\n{\n    private array $cache = [];\n\n    public function get(string $key): mixed\n    {\n        return $this->cache[$key] ?? null;\n    }\n\n    public function set(string $key, mixed $value): void\n    {\n        $this->cache[$key] = $value;  // Ne cesse de grossir !\n    }\n}\n\n// ✅ BON : Reset entre les requêtes/messages\nfinal class GoodCacheService implements ResetInterface\n{\n    private array $cache = [];\n\n    public function get(string $key): mixed\n    {\n        return $this->cache[$key] ?? null;\n    }\n\n    public function set(string $key, mixed $value): void\n    {\n        $this->cache[$key] = $value;\n    }\n\n    public function reset(): void\n    {\n        $this->cache = [];\n    }\n}\n```\n\n6. **Diagnostic avec un Event Listener** :\n```php\n<?php\n\nnamespace App\\EventSubscriber;\n\nuse Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\nuse Symfony\\Component\\Messenger\\Event\\WorkerMessageHandledEvent;\nuse Symfony\\Component\\Messenger\\Event\\WorkerRunningEvent;\n\nfinal class MemoryMonitorSubscriber implements EventSubscriberInterface\n{\n    private int $messageCount = 0;\n    private int $initialMemory;\n\n    public function __construct(private LoggerInterface $logger)\n    {\n        $this->initialMemory = memory_get_usage(true);\n    }\n\n    public static function getSubscribedEvents(): array\n    {\n        return [\n            WorkerMessageHandledEvent::class => 'onMessageHandled',\n            WorkerRunningEvent::class => 'onWorkerRunning',\n        ];\n    }\n\n    public function onMessageHandled(WorkerMessageHandledEvent $event): void\n    {\n        $this->messageCount++;\n        \n        $currentMemory = memory_get_usage(true);\n        $memoryMB = round($currentMemory / 1024 / 1024, 2);\n        $growthMB = round(($currentMemory - $this->initialMemory) / 1024 / 1024, 2);\n\n        // Log tous les 100 messages\n        if ($this->messageCount % 100 === 0) {\n            $this->logger->info('Memory status', [\n                'messages_processed' => $this->messageCount,\n                'current_memory_mb' => $memoryMB,\n                'growth_mb' => $growthMB,\n                'growth_per_message_kb' => round($growthMB * 1024 / $this->messageCount, 2),\n            ]);\n        }\n\n        // Alerte si croissance anormale\n        if ($growthMB > 50 && $this->messageCount > 10) {\n            $this->logger->warning('Potential memory leak detected', [\n                'growth_mb' => $growthMB,\n                'messages' => $this->messageCount,\n            ]);\n        }\n    }\n\n    public function onWorkerRunning(WorkerRunningEvent $event): void\n    {\n        // Vérifie la mémoire même quand le worker est idle\n        $memoryMB = round(memory_get_usage(true) / 1024 / 1024, 2);\n        \n        if ($memoryMB > 100) {\n            $this->logger->warning('High memory usage during idle', [\n                'memory_mb' => $memoryMB,\n            ]);\n        }\n    }\n}\n```\n\n7. **Script de diagnostic** :\n```php\n<?php\n\n// scripts/diagnose_memory.php\nrequire __DIR__ . '/../vendor/autoload.php';\n\nuse Doctrine\\ORM\\EntityManagerInterface;\n\n$kernel = new \\App\\Kernel('prod', false);\n$kernel->boot();\n$container = $kernel->getContainer();\n\n$em = $container->get(EntityManagerInterface::class);\n$uow = $em->getUnitOfWork();\n\necho \"Identity Map size: \" . count($uow->getIdentityMap()) . \"\\n\";\n\nforeach ($uow->getIdentityMap() as $class => $entities) {\n    echo \"  $class: \" . count($entities) . \" entities\\n\";\n}\n\necho \"\\nMemory: \" . round(memory_get_usage(true) / 1024 / 1024, 2) . \" MB\\n\";\necho \"Peak: \" . round(memory_get_peak_usage(true) / 1024 / 1024, 2) . \" MB\\n\";\n```\n\n8. **Checklist de debug** :\n```markdown\n## Memory Leak Checklist\n\n### Doctrine\n- [ ] `$em->clear()` appelé après chaque message\n- [ ] Pas de `findAll()` sur de grandes collections\n- [ ] Utilisation de `iterate()` pour les gros volumes\n- [ ] Pas de références circulaires non gérées\n\n### Services\n- [ ] Services stateful implémentent `ResetInterface`\n- [ ] Pas de cache in-memory qui grossit\n- [ ] Pas de collections statiques qui s'accumulent\n\n### Configuration\n- [ ] `--memory-limit` configuré\n- [ ] `--time-limit` configuré  \n- [ ] Supervisor avec `autorestart=true`\n\n### Monitoring\n- [ ] Logs de mémoire activés\n- [ ] Alertes sur croissance anormale\n- [ ] Métriques Prometheus/Datadog\n```\n\n**Explication** :\n\n| Cause | Solution |\n|-------|----------|\n| Doctrine Identity Map | `$em->clear()` après chaque message |\n| Services avec état | Implémenter `ResetInterface` |\n| Collections statiques | Vider dans `reset()` |\n| Event listeners qui accumulent | Reset dans le listener |\n| Logger avec gros buffer | Configurer `buffer_size` |\n\n**À retenir** :\n- Toujours utiliser `--memory-limit` en production\n- `$em->clear()` est CRUCIAL pour les workers\n- Implémentez `ResetInterface` pour tout service stateful\n- Monitorez la mémoire et alertez sur les anomalies\n- Supervisor doit redémarrer les workers automatiquement\n- Le GC de PHP ne suffit pas toujours, utilisez `gc_collect_cycles()`",
    "metadata": {
      "category": "debug",
      "topic": "messenger_advanced",
      "difficulty": "advanced",
      "tags": ["memory leak", "Messenger", "Doctrine", "worker", "debugging", "performance"]
    }
  },
  {
    "input": "Comment implémenter l'authentification JWT avec refresh tokens dans Symfony ?",
    "output": "**TL;DR** : Utilisez LexikJWTAuthenticationBundle pour les access tokens courts et implémentez un système de refresh tokens stockés en base pour renouveler l'authentification.\n\n**Problème** : Les JWT sont stateless mais ne peuvent pas être révoqués. Les refresh tokens permettent de gérer les sessions longues tout en gardant des access tokens courts.\n\n**Solution** :\n\n1. **Installation et configuration de base** :\n```bash\ncomposer require lexik/jwt-authentication-bundle\n\n# Générer les clés\nphp bin/console lexik:jwt:generate-keypair\n```\n\n```yaml\n# config/packages/lexik_jwt_authentication.yaml\nlexik_jwt_authentication:\n    secret_key: '%env(resolve:JWT_SECRET_KEY)%'\n    public_key: '%env(resolve:JWT_PUBLIC_KEY)%'\n    pass_phrase: '%env(JWT_PASSPHRASE)%'\n    token_ttl: 900  # 15 minutes (access token court)\n    \n    # Claims personnalisés\n    set_cookies: {}\n    token_extractors:\n        authorization_header:\n            enabled: true\n            prefix: Bearer\n            name: Authorization\n```\n\n2. **Entité RefreshToken** :\n```php\n<?php\n\nnamespace App\\Entity;\n\nuse Doctrine\\ORM\\Mapping as ORM;\n\n#[ORM\\Entity(repositoryClass: RefreshTokenRepository::class)]\n#[ORM\\Table(name: 'refresh_tokens')]\n#[ORM\\Index(columns: ['expires_at'], name: 'idx_refresh_token_expires')]\nclass RefreshToken\n{\n    #[ORM\\Id]\n    #[ORM\\Column(type: 'string', length: 64)]\n    private string $id;\n\n    #[ORM\\ManyToOne(targetEntity: User::class)]\n    #[ORM\\JoinColumn(nullable: false, onDelete: 'CASCADE')]\n    private User $user;\n\n    #[ORM\\Column(type: 'datetime_immutable')]\n    private \\DateTimeImmutable $expiresAt;\n\n    #[ORM\\Column(type: 'datetime_immutable')]\n    private \\DateTimeImmutable $createdAt;\n\n    #[ORM\\Column(type: 'string', length: 45, nullable: true)]\n    private ?string $ipAddress = null;\n\n    #[ORM\\Column(type: 'string', length: 255, nullable: true)]\n    private ?string $userAgent = null;\n\n    #[ORM\\Column(type: 'boolean')]\n    private bool $revoked = false;\n\n    private function __construct() {}\n\n    public static function create(\n        User $user,\n        int $ttlDays = 30,\n        ?string $ipAddress = null,\n        ?string $userAgent = null,\n    ): self {\n        $token = new self();\n        $token->id = bin2hex(random_bytes(32));\n        $token->user = $user;\n        $token->expiresAt = new \\DateTimeImmutable(\"+{$ttlDays} days\");\n        $token->createdAt = new \\DateTimeImmutable();\n        $token->ipAddress = $ipAddress;\n        $token->userAgent = $userAgent ? substr($userAgent, 0, 255) : null;\n        \n        return $token;\n    }\n\n    public function getId(): string\n    {\n        return $this->id;\n    }\n\n    public function getUser(): User\n    {\n        return $this->user;\n    }\n\n    public function isValid(): bool\n    {\n        return !$this->revoked && $this->expiresAt > new \\DateTimeImmutable();\n    }\n\n    public function revoke(): void\n    {\n        $this->revoked = true;\n    }\n}\n```\n\n3. **Service de gestion des tokens** :\n```php\n<?php\n\nnamespace App\\Security;\n\nuse App\\Entity\\RefreshToken;\nuse App\\Entity\\User;\nuse App\\Repository\\RefreshTokenRepository;\nuse Doctrine\\ORM\\EntityManagerInterface;\nuse Lexik\\Bundle\\JWTAuthenticationBundle\\Services\\JWTTokenManagerInterface;\nuse Symfony\\Component\\HttpFoundation\\RequestStack;\n\nfinal class TokenManager\n{\n    public function __construct(\n        private JWTTokenManagerInterface $jwtManager,\n        private RefreshTokenRepository $refreshTokenRepository,\n        private EntityManagerInterface $em,\n        private RequestStack $requestStack,\n        private int $refreshTokenTtlDays = 30,\n    ) {}\n\n    public function createTokenPair(User $user): array\n    {\n        $request = $this->requestStack->getCurrentRequest();\n        \n        // Access token JWT\n        $accessToken = $this->jwtManager->create($user);\n        \n        // Refresh token stocké en base\n        $refreshToken = RefreshToken::create(\n            user: $user,\n            ttlDays: $this->refreshTokenTtlDays,\n            ipAddress: $request?->getClientIp(),\n            userAgent: $request?->headers->get('User-Agent'),\n        );\n        \n        $this->em->persist($refreshToken);\n        $this->em->flush();\n\n        return [\n            'access_token' => $accessToken,\n            'refresh_token' => $refreshToken->getId(),\n            'expires_in' => 900,  // 15 minutes\n            'token_type' => 'Bearer',\n        ];\n    }\n\n    public function refreshAccessToken(string $refreshTokenId): ?array\n    {\n        $refreshToken = $this->refreshTokenRepository->find($refreshTokenId);\n\n        if (!$refreshToken || !$refreshToken->isValid()) {\n            return null;\n        }\n\n        $user = $refreshToken->getUser();\n\n        // Vérifie que l'utilisateur est toujours actif\n        if (!$user->isActive()) {\n            $refreshToken->revoke();\n            $this->em->flush();\n            return null;\n        }\n\n        // Rotation du refresh token (sécurité)\n        $refreshToken->revoke();\n        \n        return $this->createTokenPair($user);\n    }\n\n    public function revokeRefreshToken(string $refreshTokenId): void\n    {\n        $refreshToken = $this->refreshTokenRepository->find($refreshTokenId);\n        \n        if ($refreshToken) {\n            $refreshToken->revoke();\n            $this->em->flush();\n        }\n    }\n\n    public function revokeAllUserTokens(User $user): void\n    {\n        $this->refreshTokenRepository->revokeAllForUser($user);\n    }\n}\n```\n\n4. **Controller d'authentification** :\n```php\n<?php\n\nnamespace App\\Controller\\Api;\n\nuse App\\Entity\\User;\nuse App\\Security\\TokenManager;\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\PasswordHasher\\Hasher\\UserPasswordHasherInterface;\nuse Symfony\\Component\\Routing\\Attribute\\Route;\nuse Symfony\\Component\\Validator\\Constraints as Assert;\nuse Symfony\\Component\\Validator\\Validator\\ValidatorInterface;\n\n#[Route('/api/auth', name: 'api_auth_')]\nfinal class AuthController extends AbstractController\n{\n    public function __construct(\n        private TokenManager $tokenManager,\n        private UserPasswordHasherInterface $passwordHasher,\n        private ValidatorInterface $validator,\n    ) {}\n\n    #[Route('/login', name: 'login', methods: ['POST'])]\n    public function login(Request $request, UserRepository $userRepository): JsonResponse\n    {\n        $data = json_decode($request->getContent(), true);\n\n        $constraints = new Assert\\Collection([\n            'email' => [new Assert\\NotBlank(), new Assert\\Email()],\n            'password' => [new Assert\\NotBlank()],\n        ]);\n\n        $errors = $this->validator->validate($data, $constraints);\n        if (count($errors) > 0) {\n            return $this->json(['errors' => (string) $errors], Response::HTTP_BAD_REQUEST);\n        }\n\n        $user = $userRepository->findOneBy(['email' => $data['email']]);\n\n        if (!$user || !$this->passwordHasher->isPasswordValid($user, $data['password'])) {\n            return $this->json(\n                ['error' => 'Invalid credentials'],\n                Response::HTTP_UNAUTHORIZED\n            );\n        }\n\n        if (!$user->isActive()) {\n            return $this->json(\n                ['error' => 'Account disabled'],\n                Response::HTTP_FORBIDDEN\n            );\n        }\n\n        $tokens = $this->tokenManager->createTokenPair($user);\n\n        return $this->json($tokens);\n    }\n\n    #[Route('/refresh', name: 'refresh', methods: ['POST'])]\n    public function refresh(Request $request): JsonResponse\n    {\n        $data = json_decode($request->getContent(), true);\n        $refreshToken = $data['refresh_token'] ?? null;\n\n        if (!$refreshToken) {\n            return $this->json(\n                ['error' => 'Refresh token required'],\n                Response::HTTP_BAD_REQUEST\n            );\n        }\n\n        $tokens = $this->tokenManager->refreshAccessToken($refreshToken);\n\n        if (!$tokens) {\n            return $this->json(\n                ['error' => 'Invalid or expired refresh token'],\n                Response::HTTP_UNAUTHORIZED\n            );\n        }\n\n        return $this->json($tokens);\n    }\n\n    #[Route('/logout', name: 'logout', methods: ['POST'])]\n    public function logout(Request $request): JsonResponse\n    {\n        $data = json_decode($request->getContent(), true);\n        $refreshToken = $data['refresh_token'] ?? null;\n\n        if ($refreshToken) {\n            $this->tokenManager->revokeRefreshToken($refreshToken);\n        }\n\n        return $this->json(['message' => 'Logged out successfully']);\n    }\n\n    #[Route('/logout-all', name: 'logout_all', methods: ['POST'])]\n    public function logoutAll(): JsonResponse\n    {\n        /** @var User $user */\n        $user = $this->getUser();\n        $this->tokenManager->revokeAllUserTokens($user);\n\n        return $this->json(['message' => 'All sessions revoked']);\n    }\n}\n```\n\n5. **Configuration sécurité** :\n```yaml\n# config/packages/security.yaml\nsecurity:\n    password_hashers:\n        App\\Entity\\User:\n            algorithm: auto\n\n    providers:\n        app_user_provider:\n            entity:\n                class: App\\Entity\\User\n                property: email\n\n    firewalls:\n        dev:\n            pattern: ^/(_(profiler|wdt)|css|images|js)/\n            security: false\n\n        # Routes d'auth publiques\n        auth:\n            pattern: ^/api/auth/(login|refresh)$\n            stateless: true\n            security: false\n\n        # API protégée par JWT\n        api:\n            pattern: ^/api\n            stateless: true\n            jwt: ~\n\n    access_control:\n        - { path: ^/api/auth/(login|refresh), roles: PUBLIC_ACCESS }\n        - { path: ^/api, roles: IS_AUTHENTICATED_FULLY }\n```\n\n6. **Cleanup des tokens expirés** :\n```php\n<?php\n\nnamespace App\\Command;\n\nuse App\\Repository\\RefreshTokenRepository;\nuse Symfony\\Component\\Console\\Attribute\\AsCommand;\nuse Symfony\\Component\\Console\\Command\\Command;\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\n\n#[AsCommand(\n    name: 'app:refresh-tokens:cleanup',\n    description: 'Remove expired refresh tokens'\n)]\nfinal class CleanupRefreshTokensCommand extends Command\n{\n    public function __construct(\n        private RefreshTokenRepository $repository,\n    ) {\n        parent::__construct();\n    }\n\n    protected function execute(InputInterface $input, OutputInterface $output): int\n    {\n        $deleted = $this->repository->deleteExpired();\n        $output->writeln(\"<info>Deleted $deleted expired tokens</info>\");\n        \n        return Command::SUCCESS;\n    }\n}\n```\n\n**Explication** :\n\n| Token | Durée | Stockage | Usage |\n|-------|-------|----------|-------|\n| Access Token (JWT) | 15 min | Client (memory) | Authentification API |\n| Refresh Token | 30 jours | Base de données | Renouvellement access token |\n\n**Rotation des tokens** : À chaque refresh, l'ancien refresh token est révoqué et un nouveau est créé. Cela limite l'impact d'un vol de token.\n\n**À retenir** :\n- Access tokens courts (15 min) limitent la fenêtre d'exploitation\n- Refresh tokens en base permettent la révocation\n- Rotation des refresh tokens à chaque utilisation\n- Stockez IP et User-Agent pour détecter les anomalies\n- Nettoyez régulièrement les tokens expirés\n- Endpoint `/logout-all` pour révoquer toutes les sessions",
    "metadata": {
      "category": "concepts",
      "topic": "security_advanced",
      "difficulty": "advanced",
      "tags": ["JWT", "authentification", "refresh token", "sécurité", "API", "stateless"]
    }
  }
]
